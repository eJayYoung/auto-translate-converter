{"version":3,"sources":["../../../lib/utils/stream-base64.js"],"names":["Stream","require","utils","StreamBuf","module","exports","pipes","inherits","Duplex","write","cork","uncork","end","read","setEncoding","encoding","pause","resume","isPaused","pipe","destination","push","unpipe","filter","unshift","Error","wrap"],"mappings":"AAAA;;AAEA,IAAIA,SAASC,QAAQ,QAAR,CAAb;AACA,IAAIC,QAAQD,QAAQ,SAAR,CAAZ;;AAEA;AACA;AACA;AACA,IAAIE,YAAYC,OAAOC,OAAP,GAAiB,YAAW;AAC1C;AACA,OAAKC,KAAL,GAAa,EAAb;AACD,CAHD;;AAKAJ,MAAMK,QAAN,CAAeJ,SAAf,EAA0BH,OAAOQ,MAAjC,EAAyC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEAC,SAAO,iBAAS,oBAAsB;AACpC,WAAO,IAAP;AACD,GAVsC;AAWvCC,QAAM,gBAAW,CAChB,CAZsC;AAavCC,UAAQ,kBAAW,CAClB,CAdsC;AAevCC,OAAK,eAAS,+BAAiC,CAC9C,CAhBsC;;AAkBvC;AACA;AACA;AACA;AACA;AACA;AACAC,QAAM,gBAAS,UAAY,CAC1B,CAzBsC;AA0BvCC,eAAa,qBAASC,QAAT,EAAmB;AAC9B;AACA,SAAKA,QAAL,GAAgBA,QAAhB;AACD,GA7BsC;AA8BvCC,SAAO,iBAAW,CACjB,CA/BsC;AAgCvCC,UAAQ,kBAAW,CAClB,CAjCsC;AAkCvCC,YAAU,oBAAW,CACpB,CAnCsC;AAoCvCC,QAAM,cAASC,WAAT,EAAsB;AAC1B;AACA,SAAKd,KAAL,CAAWe,IAAX,CAAgBD,WAAhB;AACD,GAvCsC;AAwCvCE,UAAQ,gBAASF,WAAT,EAAsB;AAC5B;AACA,SAAKd,KAAL,GAAa,KAAKA,KAAL,CAAWiB,MAAX,CAAkB,UAASJ,IAAT,EAAe;AAC5C,aAAOA,SAASC,WAAhB;AACD,KAFY,CAAb;AAGD,GA7CsC;AA8CvCI,WAAS,mBAAS,WAAa;AAC7B;AACA;AACA,UAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD,GAlDsC;AAmDvCC,QAAM,gBAAS,YAAc;AAC3B;AACA,UAAM,IAAID,KAAJ,CAAU,iBAAV,CAAN;AACD;AAtDsC,CAAzC","file":"stream-base64.js","sourcesContent":["'use strict';\r\n\r\nvar Stream = require('stream');\r\nvar utils = require('./utils');\r\n\r\n// =============================================================================\r\n// StreamBase64 - A utility to convert to/from base64 stream\r\n// Note: does not buffer data, must be piped\r\nvar StreamBuf = module.exports = function() {\r\n  // consuming pipe streams go here\r\n  this.pipes = [];\r\n};\r\n\r\nutils.inherits(StreamBuf, Stream.Duplex, {\r\n  // writable\r\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\r\n  // finish - end() has been called\r\n  // pipe(src) - pipe() has been called on readable\r\n  // unpipe(src) - unpipe() has been called on readable\r\n  // error - duh\r\n\r\n  write: function(/* data, encoding */) {\r\n    return true;\r\n  },\r\n  cork: function() {\r\n  },\r\n  uncork: function() {\r\n  },\r\n  end: function(/* chunk, encoding, callback */) {\r\n  },\r\n\r\n  // readable\r\n  // event readable - some data is now available\r\n  // event data - switch to flowing mode - feeds chunks to handler\r\n  // event end - no more data\r\n  // event close - optional, indicates upstream close\r\n  // event error - duh\r\n  read: function(/* size */) {\r\n  },\r\n  setEncoding: function(encoding) {\r\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\r\n    this.encoding = encoding;\r\n  },\r\n  pause: function() {\r\n  },\r\n  resume: function() {\r\n  },\r\n  isPaused: function() {\r\n  },\r\n  pipe: function(destination) {\r\n    // add destination to pipe list & write current buffer\r\n    this.pipes.push(destination);\r\n  },\r\n  unpipe: function(destination) {\r\n    // remove destination from pipe list\r\n    this.pipes = this.pipes.filter(function(pipe) {\r\n      return pipe !== destination;\r\n    });\r\n  },\r\n  unshift: function(/* chunk */) {\r\n    // some numpty has read some data that's not for them and they want to put it back!\r\n    // Might implement this some day\r\n    throw new Error('Not Implemented');\r\n  },\r\n  wrap: function(/* stream */) {\r\n    // not implemented\r\n    throw new Error('Not Implemented');\r\n  }\r\n});\r\n"]}