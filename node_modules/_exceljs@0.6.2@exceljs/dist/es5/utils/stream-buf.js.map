{"version":3,"sources":["../../../lib/utils/stream-buf.js"],"names":["Stream","require","PromishLib","utils","StringBuf","StringChunk","data","encoding","_data","_encoding","prototype","length","toBuffer","copy","target","targetOffset","offset","_buffer","Buffer","StringBufChunk","_buf","BufferChunk","ReadWriteBuf","size","buffer","iRead","iWrite","buf","eod","full","read","undefined","write","chunk","Math","min","StreamBuf","module","exports","options","bufSize","buffers","batch","corked","inPos","outPos","pipes","paused","inherits","Duplex","concat","map","rwBuf","_getWritableBuffer","last","push","_pipe","pipe","Promish","resolve","promises","all","then","nop","_writeToBuffers","inLen","callback","Function","shift","process","nextTick","emit","cork","_flush","uncork","end","writeComplete","error","forEach","first","filter","Boolean","setEncoding","pause","resume","isPaused","destination","unpipe","unshift","Error","wrap"],"mappings":"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","file":"stream-buf.js","sourcesContent":["/**\r\n * Copyright (c) 2015-2017 Guyon Roche\r\n * LICENCE: MIT - please refer to LICENCE file included with this module\r\n * or https://github.com/guyonroche/exceljs/blob/master/LICENSE\r\n */\r\n\r\n'use strict';\r\n\r\nvar Stream = require('stream');\r\nvar PromishLib = require('./promish');\r\n\r\nvar utils = require('./utils');\r\nvar StringBuf = require('./string-buf');\r\n\r\n\r\n// =============================================================================\r\n// data chunks - encapsulating incoming data\r\nvar StringChunk = function(data, encoding) {\r\n  this._data = data;\r\n  this._encoding = encoding;\r\n};\r\nStringChunk.prototype = {\r\n  get length() {\r\n    return this.toBuffer().length;\r\n  },\r\n  // copy to target buffer\r\n  copy: function(target, targetOffset, offset, length) {\r\n    return this.toBuffer().copy(target, targetOffset, offset, length);\r\n  },\r\n  toBuffer: function() {\r\n    if (!this._buffer) {\r\n      this._buffer = new Buffer(this._data, this._encoding);\r\n    }\r\n    return this._buffer;\r\n  }\r\n};\r\nvar StringBufChunk = function(data) {\r\n  this._data = data;\r\n};\r\nStringBufChunk.prototype = {\r\n  get length() {\r\n    return this._data.length;\r\n  },\r\n  // copy to target buffer\r\n  copy: function(target, targetOffset, offset, length) {\r\n    // eslint-disable-next-line no-underscore-dangle\r\n    return this._data._buf.copy(target, targetOffset, offset, length);\r\n  },\r\n  toBuffer: function() {\r\n    return this._data.toBuffer();\r\n  }\r\n};\r\nvar BufferChunk = function(data) {\r\n  this._data = data;\r\n};\r\nBufferChunk.prototype = {\r\n  get length() {\r\n    return this._data.length;\r\n  },\r\n  // copy to target buffer\r\n  copy: function(target, targetOffset, offset, length) {\r\n    this._data.copy(target, targetOffset, offset, length);\r\n  },\r\n  toBuffer: function() {\r\n    return this._data;\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// ReadWriteBuf - a single buffer supporting simple read-write\r\nvar ReadWriteBuf = function(size) {\r\n  this.size = size;\r\n  // the buffer\r\n  this.buffer = new Buffer(size);\r\n  // read index\r\n  this.iRead = 0;\r\n  // write index\r\n  this.iWrite = 0;\r\n};\r\nReadWriteBuf.prototype = {\r\n  toBuffer: function() {\r\n    if ((this.iRead === 0) && (this.iWrite === this.size)) {\r\n      return this.buffer;\r\n    }\r\n\r\n    var buf = new Buffer(this.iWrite - this.iRead);\r\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\r\n    return buf;\r\n  },\r\n  get length() {\r\n    return this.iWrite - this.iRead;\r\n  },\r\n  get eod() {\r\n    return this.iRead === this.iWrite;\r\n  },\r\n  get full() {\r\n    return this.iWrite === this.size;\r\n  },\r\n  read: function(size) {\r\n    var buf;\r\n    // read size bytes from buffer and return buffer\r\n    if (size === 0) {\r\n      // special case - return null if no data requested\r\n      return null;\r\n    }\r\n\r\n    if ((size === undefined) || (size >= this.length)) {\r\n      // if no size specified or size is at least what we have then return all of the bytes\r\n      buf = this.toBuffer();\r\n      this.iRead = this.iWrite;\r\n      return buf;\r\n    }\r\n\r\n    // otherwise return a chunk\r\n    buf = new Buffer(size);\r\n    this.buffer.copy(buf, 0, this.iRead, size);\r\n    this.iRead += size;\r\n    return buf;\r\n  },\r\n  write: function(chunk, offset, length) {\r\n    // write as many bytes from data from optional source offset\r\n    // and return number of bytes written\r\n    var size = Math.min(length, this.size - this.iWrite);\r\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\r\n    this.iWrite += size;\r\n    return size;\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// StreamBuf - a multi-purpose read-write stream\r\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\r\n//  As StreamHub - pipe to multiple writables\r\n//  As readable stream - feed data into the writable part and have some other code read from it.\r\nvar StreamBuf = module.exports = function(options) {\r\n  options = options || {};\r\n  this.bufSize = options.bufSize || 1024 * 1024;\r\n  this.buffers = [];\r\n\r\n  // batch mode fills a buffer completely before passing the data on\r\n  // to pipes or 'readable' event listeners\r\n  this.batch = options.batch || false;\r\n\r\n  this.corked = false;\r\n  // where in the current writable buffer we're up to\r\n  this.inPos = 0;\r\n\r\n  // where in the current readable buffer we've read up to\r\n  this.outPos = 0;\r\n\r\n  // consuming pipe streams go here\r\n  this.pipes = [];\r\n\r\n  // controls emit('data')\r\n  this.paused = false;\r\n\r\n  this.encoding = null;\r\n};\r\n\r\nutils.inherits(StreamBuf, Stream.Duplex, {\r\n\r\n  toBuffer: function() {\r\n    switch (this.buffers.length) {\r\n      case 0:\r\n        return null;\r\n      case 1:\r\n        return this.buffers[0].toBuffer();\r\n      default:\r\n        return Buffer.concat(this.buffers.map(function(rwBuf) { return rwBuf.toBuffer(); }));\r\n    }\r\n  },\r\n\r\n  // writable\r\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\r\n  // finish - end() has been called\r\n  // pipe(src) - pipe() has been called on readable\r\n  // unpipe(src) - unpipe() has been called on readable\r\n  // error - duh\r\n\r\n  _getWritableBuffer: function() {\r\n    if (this.buffers.length) {\r\n      var last = this.buffers[this.buffers.length - 1];\r\n      if (!last.full) {\r\n        return last;\r\n      }\r\n    }\r\n    var buf = new ReadWriteBuf(this.bufSize);\r\n    this.buffers.push(buf);\r\n    return buf;\r\n  },\r\n\r\n  _pipe: function(chunk) {\r\n    var write = function(pipe) {\r\n      return new PromishLib.Promish(function(resolve) {\r\n        pipe.write(chunk.toBuffer(), function() {\r\n          resolve();\r\n        });\r\n      });\r\n    };\r\n    var promises = this.pipes.map(write);\r\n    return promises.length ?\r\n      PromishLib.Promish.all(promises).then(utils.nop) :\r\n      PromishLib.Promish.resolve();\r\n  },\r\n  _writeToBuffers: function(chunk) {\r\n    var inPos = 0;\r\n    var inLen = chunk.length;\r\n    while (inPos < inLen) {\r\n      // find writable buffer\r\n      var buffer = this._getWritableBuffer();\r\n\r\n      // write some data\r\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\r\n    }\r\n  },\r\n  write: function(data, encoding, callback) {\r\n    if (encoding instanceof Function) {\r\n      callback = encoding;\r\n      encoding = 'utf8';\r\n    }\r\n    callback = callback || utils.nop;\r\n\r\n    // encapsulate data into a chunk\r\n    var chunk;\r\n    if (data instanceof StringBuf) {\r\n      chunk = new StringBufChunk(data);\r\n    } else if (data instanceof Buffer) {\r\n      chunk = new BufferChunk(data);\r\n    } else {\r\n      // assume string\r\n      chunk = new StringChunk(data, encoding);\r\n    }\r\n\r\n    // now, do something with the chunk\r\n    if (this.pipes.length) {\r\n      if (this.batch) {\r\n        this._writeToBuffers(chunk);\r\n        while (!this.corked && (this.buffers.length > 1)) {\r\n          this._pipe(this.buffers.shift());\r\n        }\r\n      } else if (!this.corked) {\r\n        this._pipe(chunk).then(callback);\r\n      } else {\r\n        this._writeToBuffers(chunk);\r\n        process.nextTick(callback);\r\n      }\r\n    } else {\r\n      if (!this.paused) {\r\n        this.emit('data', chunk.toBuffer());\r\n      }\r\n\r\n      this._writeToBuffers(chunk);\r\n      this.emit('readable');\r\n    }\r\n\r\n    return true;\r\n  },\r\n  cork: function() {\r\n    this.corked = true;\r\n  },\r\n  _flush: function(/* destination */) {\r\n    // if we have comsumers...\r\n    if (this.pipes.length) {\r\n      // and there's stuff not written\r\n      while (this.buffers.length) {\r\n        this._pipe(this.buffers.shift());\r\n      }\r\n    }\r\n  },\r\n  uncork: function() {\r\n    this.corked = false;\r\n    this._flush();\r\n  },\r\n  end: function(chunk, encoding, callback) {\r\n    var writeComplete = error => {\r\n      if (error) {\r\n        callback(error);\r\n      } else {\r\n        this._flush();\r\n        this.pipes.forEach(pipe => { pipe.end(); });\r\n        this.emit('finish');\r\n      }\r\n    };\r\n    if (chunk) {\r\n      this.write(chunk, encoding, writeComplete);\r\n    } else {\r\n      writeComplete();\r\n    }\r\n  },\r\n\r\n  // readable\r\n  // event readable - some data is now available\r\n  // event data - switch to flowing mode - feeds chunks to handler\r\n  // event end - no more data\r\n  // event close - optional, indicates upstream close\r\n  // event error - duh\r\n  read: function(size) {\r\n    var buffers;\r\n    // read min(buffer, size || infinity)\r\n    if (size) {\r\n      buffers = [];\r\n      while (size && this.buffers.length && !this.buffers[0].eod) {\r\n        var first = this.buffers[0];\r\n        var buffer = first.read(size);\r\n        size -= buffer.length;\r\n        buffers.push(buffer);\r\n        if (first.eod && first.full) {\r\n          this.buffers.shift();\r\n        }\r\n      }\r\n      return Buffer.concat(buffers);\r\n    }\r\n\r\n    buffers = this.buffers.map(buf => buf.toBuffer())\r\n      .filter(Boolean);\r\n    this.buffers = [];\r\n    return Buffer.concat(buffers);\r\n  },\r\n  setEncoding: function(encoding) {\r\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\r\n    this.encoding = encoding;\r\n  },\r\n  pause: function() {\r\n    this.paused = true;\r\n  },\r\n  resume: function() {\r\n    this.paused = false;\r\n  },\r\n  isPaused: function() {\r\n    return !!this.paused;\r\n  },\r\n  pipe: function(destination) {\r\n    // add destination to pipe list & write current buffer\r\n    this.pipes.push(destination);\r\n    if (!this.paused && this.buffers.length) {\r\n      this.end();\r\n    }\r\n  },\r\n  unpipe: function(destination) {\r\n    // remove destination from pipe list\r\n    this.pipes = this.pipes.filter(function(pipe) {\r\n      return pipe !== destination;\r\n    });\r\n  },\r\n  unshift: function(/* chunk */) {\r\n    // some numpty has read some data that's not for them and they want to put it back!\r\n    // Might implement this some day\r\n    throw new Error('Not Implemented');\r\n  },\r\n  wrap: function(/* stream */) {\r\n    // not implemented\r\n    throw new Error('Not Implemented');\r\n  }\r\n});\r\n"]}